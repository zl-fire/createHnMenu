<!DOCTYPE html>
        <html>
            <head>
            <meta charset="utf-8" >
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <title>说明文档</title>
            <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9f6231e36b2965212308e701d3167983";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
            <script src="https://cdn.jsdelivr.net/npm/blogzl-indexjs@18.0.0/dist/jquery.min.js"></script>
            <style>
              /*  控制md文档显示的主体内容的位置，左右panddinf等 */
                .markdown-body {
                    box-sizing: border-box;
                    min-width: 200px;
                    width:80%;
                    float:left;
                    margin: 0 auto;
                    padding: 25px;
                }
                @media (max-width: 767px) {
                    .markdown-body {
                        padding: 15px;
                    }
                }
            </style>
            <link href="https://cdn.bootcss.com/github-markdown-css/4.0.0/github-markdown.min.css" rel="stylesheet">
            <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css" rel="stylesheet">
            </head>
            <body>
                
    <style class="zl-ver-menu-style" >
    html,
    body {
        height: 100%;
        margin: 0;
        padding: 0;
    }

    /* 菜单收缩的三角形(默认) */
    .triangle {
        display: inline-block;
        border: 5px solid transparent;
        border-top: 5px solid #191F25;
    }

    /* 菜单展开的三角形 */
    .triangle_open {
        display: inline-block;
        border: 5px solid transparent;
        border-left: 5px solid #191F25;
    }
    /* 当没有后代菜单时，默认的充填位置样式 */
    .default{
        display: inline-block;
        border: 5px solid transparent;
        border-left: 5px solid #ede4e4;
    }

    /* 菜单选中时的颜色控制 */
    .summary-active {
        background-color: #E9F2FF !important;
        color: #4285f4 !important;
        border-right: 5px solid #4285F4;
    }

    .zl-ver-menu {
       /* width: 230px; */
        width: 281px;
        background: #fff;
        border: 1px solid #e7e7e9;
        border-top-width: 0px;
        border-bottom-width: 0px;
        overflow-y: auto;
        overflow-x: hidden;
        font-size: 16px;
        display: inline-block;
        height: 100%;
        vertical-align: top;
    }

    .zl-ver-menu li {
       /* font-size: 12px; */
         font-size: 14px; 
        font-family: Microsoft YaHei;
        font-weight: 400;
        color: #70707a;
        padding-top: 10px;
        padding-bottom: 10px;
        cursor: pointer;
    }

    .zl-ver-menu .tit-menu {
        padding-bottom: 10px;
        font-size: 14px;
        font-family: Microsoft YaHei;
        font-weight: 400;
       /* color: #191f25; */
    }

    .zl-ver-menu ul {
        padding-left: 0;
    }

    .zl-ver-menu ul,
    .zl-ver-menu li {
        list-style: none;
    }
</style>
    
<style>
#anchorLinkMenu{
     color:blue;
     position:fixed;
     top:5px;
     right: 10px;
     padding:10px;
     border-radius:5px;
     box-shadow: 1px 1px 5px;
     cursor: pointer;
     opacity: 0.4;
    }
 #anchorLinkMenu:hover{
    opacity: 1;
}
#anchorLinkContent {
    opacity: 1;
    padding: 5px;
   /* width: 400px; */
    position: fixed;
    box-shadow: 1px 1px 5px;
    border-radius: 10px 0 0 10px;
    top:5px;
    right: -410px;
    background-color: #c5bcbc;
    height:97vh;
    /*  overflow: scroll;*/
    transition: all 1s;

}
</style>
  
    <script>
    createRightMenu();
    function createRightMenu() {
        //插入div和相关样式
        document.querySelector("body").innerHTML += '<div id="anchorLinkMenu">目录菜单</div><div id="anchorLinkContent">666</div>';
        //绑定div按钮的点击事件
        var anchorLinkMene = document.querySelector("#anchorLinkMenu");
        var anchorLinkContent = document.querySelector("#anchorLinkContent");

        //给div菜单内容添加实际内容
        // var realMenu = document.querySelector("#" + realMenuId);
        // anchorLinkContent.appendChild(realMenu.cloneNode(true));
        $(anchorLinkContent).html(`<section class='zl-ver-menu'><ul class='index-ver-nav'><li data-menu-id="0" data-id="zl-docx2html-----docx文档转换为网页" data-parent-id="root" ><div class="tit-menu" style="padding-left: 20px" ><i class="triangle"></i> <span>1. zl-docx2html --- docx文档转换为网页</span></div><ul class='index-ver-nav'><li data-menu-id="1" data-id="安装" data-parent-id="0" style="padding-left: 40px"> <i class="default"></i> <span>1.1. 安装</span> </li><li data-menu-id="2" data-id="引入与使用" data-parent-id="0" style="padding-left: 40px"> <i class="default"></i> <span>1.2. 引入与使用</span> </li><li data-menu-id="3" data-id="主要方法说明" data-parent-id="0" style="padding-left: 40px"> <i class="default"></i> <span>1.3. 主要方法说明</span> </li><li data-menu-id="4" data-id="工具方法说明" data-parent-id="0" style="padding-left: 40px"> <i class="default"></i> <span>1.4. 工具方法说明</span> </li></ul></li></ul></section>`);
    
        // anchorLinkMene.onclick = function () {
        //     anchorLinkContent.style.cssText = "right:0;";
        // };
        // //当点击了具体的内容菜单后，隐藏此菜单
        // anchorLinkContent.onclick = function () {
        //     anchorLinkContent.style.cssText = "right:-410px;";
        // };

        // 控制菜单点击后的样式

        function resizefn(){
            if(document.documentElement.clientWidth<1400){
                anchorLinkContent.style.cssText = "right:-410px;"
                anchorLinkMene.onmouseenter = function () {
                    anchorLinkContent.style.cssText = "right:0;"
                }
                anchorLinkContent.onmouseleave = function () {
                    anchorLinkContent.style.cssText = "right:-410px;"
                }
            }
            else{
                anchorLinkContent.style.cssText = "right:0;"
                anchorLinkMene.onmouseenter=null;
                anchorLinkContent.onmouseleave=null;
            }
        }
        resizefn();//初始化执行一次
        window.onresize=function(){
            resizefn();
        }
    }
    </script>
    <html><head></head><body><section>
        <style>
           body{
               padding-left:20px !important;
               padding-right:20px !important;;
           }
        </style>
            
<style>
    h1 {
        font-size: 32px;
    }

    h2 {
        font-size: 24px;
    }

    h3 {
        font-size: 18.72px;
    }

    h4 {
        font-size: 16px;
    }

    h5 {
        font-size: 13.28px;
    }

    h6 {
        font-size: 12px;
    }
</style>
    <article class="markdown-body"><h1 id="zl-docx2html-----docx文档转换为网页">1. zl-docx2html --- docx文档转换为网页</h1>
<p><strong>此模块主要功能</strong></p>
<ol>
<li>docx2html：将单个docx文档转换为html网页文件，node环境可用</li>
<li>batchDocx2html：将批量docx文档转换为html网页文件，node环境可用</li>
<li>addMenu2Page：解析html字符串，自动生成导航锚点菜单，node环境可用</li>
<li>utils：开发过程中产生的一些工具函数<ul>
<li>addHtmlTag, //给html主体内容字符串包裹html,head,body标签</li>
<li>createEndMenuTempla,//返回要固定定位的菜单容器字符串</li>
<li>numberToChinese,//将阿拉伯数字转换成中文的大写数字</li>
<li>numToEng0_26,//通过ASCII码的方式将1-26转换为字母a-z(可大写可小写)</li>
<li>numToEng,//将数字转换为英文字母，大于26的数字也可以，并可控制大写和小写</li>
<li>resolveHtmlPageMenu,//传入能获取所有页面元素的$对象，从中获取由h1---h6组合成的树结构（你应该使用cheerio,适用于nodejs环境）
<img src="./assets/screenshot.png" alt="screenshot"><h2 id="安装">1.1. 安装</h2>
</li>
</ul>
</li>
</ol>
<pre><code class="language-js">npm i <span class="hljs-built_in">zl</span>-docx2html -S
</code></pre>
<h2 id="引入与使用">1.2. 引入与使用</h2>
<pre><code class="language-js">
<span class="hljs-keyword">const</span> { batchDocx2html, docx2html ,util } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"zl-docx2html"</span>);

<span class="hljs-comment">// 批量转换docx文档为html</span>
<span class="hljs-title function_">batchDocx2html</span>({
    <span class="hljs-attr">dirPath</span>: <span class="hljs-string">"./doctest"</span>,
    <span class="hljs-attr">outPath</span>:<span class="hljs-string">"./HTML"</span>,
    <span class="hljs-attr">showWarnMessage</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">showExeResult</span>:<span class="hljs-literal">false</span>
});

<span class="hljs-comment">// 转换单个docx文档为html</span>
 <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
 <span class="hljs-keyword">let</span> { docx2html } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"zl-docx2html"</span>);
 <span class="hljs-keyword">let</span> fileName = <span class="hljs-string">"666.docx"</span>;
 <span class="hljs-keyword">let</span> docxPath = path.<span class="hljs-title function_">join</span>(path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">"."</span>), fileName); <span class="hljs-comment">//通过path.join可以解决mac和window路径规则不一致的情况</span>
 <span class="hljs-keyword">let</span> outPath = path.<span class="hljs-title function_">join</span>(path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">"."</span>), <span class="hljs-string">"/aa/bb/cc/dd/"</span>, fileName.<span class="hljs-title function_">split</span>(<span class="hljs-string">"."</span>)[<span class="hljs-number">0</span>]+<span class="hljs-string">".html"</span>);
 (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
     <span class="hljs-keyword">await</span> <span class="hljs-title function_">docx2html</span>({
         <span class="hljs-attr">docxPath</span>: docxPath,
         <span class="hljs-attr">outPath</span>: outPath,
         <span class="hljs-attr">showWarnMessage</span>: <span class="hljs-literal">false</span>,
     })
 })()
</code></pre>
<h2 id="主要方法说明">1.3. 主要方法说明</h2>
<pre><code class="language-js">    addMenu2Page,  //如果已有html字符串 就可以调用这个函数
    docx2html, //如果要从docx文档转换为含有菜单的html页面 就可以调用这个函数
    batchDocx2html,//传入一个目录路径，将此路径下的所有docx文件批量转换为html文件（不管层级有多深）

-------------------------------addMenu2Page----------------------------------------------
/**
    * @description 接收一个html字页面符串--给标题注入id--&gt;得到tree菜单结构---》生成菜单模板--》注入到页面内容并返回
    * @<span class="hljs-keyword">param</span> {Object} <span class="hljs-keyword">parObj</span> 完整的参数对象信息
    * @<span class="hljs-keyword">param</span> {String} <span class="hljs-keyword">parObj</span>.html 要处理的html字符串
    * @<span class="hljs-keyword">param</span> {String} <span class="hljs-keyword">parObj</span>.fileName 生成的html文件名（如果存在html,head,外层的标签的话）
    * @<span class="hljs-keyword">param</span> {Object} <span class="hljs-keyword">other</span> 接收其他信息的对象
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">other</span>.isAddHtmlHead  是否不给转换后的文档添加html,body等标签,默认为true
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">other</span>.isAddMenu   是否给转换后的html文件注入锚点菜单,默认为true
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">other</span>.isAddOrder   是否添加手动生成的序号,默认为true
    * @author zl-fire 2021/09/01
    * @example
    * let html = addMenu2Page(html, fileName);
  */
export function addMenu2Page(html: any, fileName?: string, other?: {
    isAddHtmlHead: boolean;
    isAddMenu: boolean;
    isAddOrder: boolean;
}): any;

-------------------------------batchDocx2html----------------------------------------------

/**
    * @description 传入一个目录路径，将此路径下的所有docx文件批量转换为html文件（不管层级有多深）
    * @<span class="hljs-keyword">param</span> {Object} <span class="hljs-keyword">parObj</span> 完整的参数对象信息
    * @<span class="hljs-keyword">param</span> {String} <span class="hljs-keyword">parObj</span>.dirPath 要处理目录路径，可传入绝对路径，也可传入相对路径
    * @<span class="hljs-keyword">param</span> {String} <span class="hljs-keyword">parObj</span>.outPath 要输出的html文档路径
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.isAddHtmlHead  是否给转换后的文档添加html,body等标签
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.isAddMenu   是否给转换后的html文件注入锚点菜单
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.autoHsSty   是否添加手动注入的h1--h6的大小样式
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.isAddOrder   是否添加手动生成的序号
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.isAddpagePadV   是否给页面注入默认的padding值
    * @<span class="hljs-keyword">param</span> {String} <span class="hljs-keyword">parObj</span>.manualAssignment   用户手动注入的样式对象字符串：·&lt;style&gt;...&lt;/style&gt;·
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.showWarnMessage   是否显示docx文档转换为html时的警告信息（如果有的话），默认显示
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.showExeResult   创建html文件时，是否要显示提示信息
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.isList2file   要转换的的文件树结构是否要写入文件
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.list2filePath   要转换的的文件树结构要写入文件时的文件路径
    * @author zl-fire 2021/09/01
    * @example
    *
    * <span class="hljs-keyword">let</span> { batchDocx2html } = require(<span class="hljs-string">"zl-docx2html"</span>);
    * batchDocx2html({
    *     dirPath: <span class="hljs-string">"./"</span>,
    *     outPath:<span class="hljs-string">"./HTML"</span>,
    *     showWarnMessage: false,
    * });
    *
  */
export function batchDocx2html(parObj: {
    dirPath: string;
    outPath: string;
    isAddHtmlHead: boolean;
    isAddMenu: boolean;
    autoHsSty: boolean;
    isAddOrder: boolean;
    isAddpagePadV: boolean;
    manualAssignment: boolean;
    showWarnMessage: boolean;
    showExeResult: boolean;
    isList2file: boolean;
    list2filePath: boolean;
}): Promise&lt;void&gt;;

-------------------------------docx2html----------------------------------------------

/**
    * @function  传入docx类型文档，会解析成html，同时给这个html注入菜单，最后写入指定的路径
    * @description 这是个异步函数，因为调用转换docx的内置模块时是异步的
    * @<span class="hljs-keyword">param</span> {Object} <span class="hljs-keyword">parObj</span> 完整的参数对象信息
    * @<span class="hljs-keyword">param</span> {String} <span class="hljs-keyword">parObj</span>.docxPath 要处理的docx文档路径
    * @<span class="hljs-keyword">param</span> {String} <span class="hljs-keyword">parObj</span>.outPath 要输出的html文档路径，默认为当前docx文件所在目录
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.isAddHtmlHead  是否给转换后的文档添加html,body等标签
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.isAddMenu   是否给转换后的html文件注入锚点菜单
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.autoHsSty   是否添加手动注入的h1--h6的大小样式
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.isAddOrder   是否添加手动生成的序号
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.isAddpagePadV   是否给页面注入默认的padding值
    * @<span class="hljs-keyword">param</span> {String} <span class="hljs-keyword">parObj</span>.manualAssignment   用户手动注入的样式对象字符串：·&lt;style&gt;...&lt;/style&gt;·
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.showWarnMessage   是否显示docx文档转换为html时的警告信息（如果有的话），默认显示
    * @<span class="hljs-keyword">param</span> {Boolean} <span class="hljs-keyword">parObj</span>.showExeResult   创建html文件时，是否要显示提示信息
    * @author zl-fire 2021/09/01
    * @example
    * var path = require(<span class="hljs-string">"path"</span>);
    * <span class="hljs-keyword">let</span> { docx2html } = require(<span class="hljs-string">"zl-docx2html"</span>);
    * let fileName = <span class="hljs-string">"666.docx"</span>;
    * let docxPath = path.join(path.resolve(<span class="hljs-string">"."</span>), fileName); //通过path.join可以解决mac和window路径规则不一致的情况
    * let outPath = path.join(path.resolve(<span class="hljs-string">"."</span>), <span class="hljs-string">"/aa/bb/cc/dd/"</span>, fileName.split(<span class="hljs-string">"."</span>)[0]+<span class="hljs-string">".html"</span>);
    * (async function () {
    *     await docx2html({
    *         docxPath: docxPath,
    *         outPath: outPath,
    *         showWarnMessage: false,
    *     })
    * })()
  */
export function docx2html(parObj: {
    docxPath: string;
    outPath: string;
    isAddHtmlHead: boolean;
    isAddMenu: boolean;
    autoHsSty: boolean;
    isAddOrder: boolean;
    isAddpagePadV: boolean;
    manualAssignment: boolean;
    showWarnMessage: boolean;
    showExeResult: boolean;
}): Promise&lt;void&gt;;
export namespace <span class="hljs-keyword">utils</span> {
    export { addHtmlTag };
    <span class="hljs-keyword">export</span> { createEndMenuTempla };
    <span class="hljs-keyword">export</span> { numberToChinese };
    <span class="hljs-keyword">export</span> { numToEng };
    <span class="hljs-keyword">export</span> { numToEng0_26 };
    <span class="hljs-keyword">export</span> { resolveHtmlPageMenu };
}
export var __esModule: boolean;
</code></pre>
<h2 id="工具方法说明">1.4. 工具方法说明</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { util } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"zl-docx2html"</span>);

<span class="hljs-keyword">let</span> {addHtmlTag,createEndMenuTempla,numberToChinese,numToEng,numToEng0_26,resolveHtmlPageMenu} = util;

    addHtmlTag, <span class="hljs-comment">//给html主体内容字符串包裹html,head,body标签</span>
    createEndMenuTempla,<span class="hljs-comment">//返回要固定定位的菜单容器字符串</span>
    numberToChinese,<span class="hljs-comment">//将阿拉伯数字转换成中文的大写数字</span>
    numToEng,<span class="hljs-comment">//将数字转换为英文字母，大于26的数字也可以，并可控制大写和小写</span>
    numToEng0_26,<span class="hljs-comment">//通过ASCII码的方式将1-26转换为字母a-z(可大写可小写)</span>
    resolveHtmlPageMenu,<span class="hljs-comment">//传入能获取所有页面元素的$对象，从中获取由h1---h6组合成的树结构</span>

-------------------------------addHtmlTag----------------------------------------------

<span class="hljs-comment">/**
    * <span class="hljs-doctag">@description</span> 如果内容没有外层的html，body包裹，则可使用此函数进行处理
    * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} content 要处理的html字符串
    * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} fileName html字符串的名字
    * <span class="hljs-doctag">@author</span> <span class="hljs-variable">zl</span>-fire 2021/09/01
    * <span class="hljs-doctag">@return</span> {<span class="hljs-type">string</span>} 包裹了html,body的最终的字符串
  */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addHtmlTag</span>(<span class="hljs-params">content: <span class="hljs-built_in">string</span>, fileName: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;

-------------------------------createEndMenuTempla--------------------------------------
<span class="hljs-comment">/**
    * <span class="hljs-doctag">@description</span> 返回要创建固定定位的菜单容器字符串（固定格式），包含了html+css+js, 接收一个具体的菜单内容作为参数
    * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} realMenu 菜单html字符串
    * <span class="hljs-doctag">@author</span> <span class="hljs-variable">zl</span>-fire 2021/09/01
    * <span class="hljs-doctag">@return</span> {<span class="hljs-type">string</span>} 生成的最终的包含了样式和js逻辑的菜单字符串
  */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createEndMenuTempla</span>(<span class="hljs-params">realMenu: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;

-------------------------------numberToChinese--------------------------------------
<span class="hljs-comment">/**
    * <span class="hljs-doctag">@description</span> 将阿拉伯数字转换成中文的大写数字
    * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} num 要转换的阿拉伯数字
    * <span class="hljs-doctag">@author</span> <span class="hljs-variable">zl</span>-fire 2021/09/01
    * <span class="hljs-doctag">@return</span> {<span class="hljs-type">string</span>} 中文的大写数字字符串
    * <span class="hljs-doctag">@example</span>
    * let n=numberToChinese(12);//返回'十二'
  */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">numberToChinese</span>(<span class="hljs-params">num: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span>;


-------------------------------numToEng--------------------------------------
<span class="hljs-comment">/**
    * <span class="hljs-doctag">@description</span> 将数字转换为英文字母，大于26的数字也可以，并可控制大写和小写
    * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} i 要转换的阿拉伯数字
    * <span class="hljs-doctag">@param</span> {<span class="hljs-type">boolean</span>} big true:大写，false|不传:为小写
    * <span class="hljs-doctag">@author</span> <span class="hljs-variable">zl</span>-fire 2021/09/01
    * <span class="hljs-doctag">@return</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">a</span>-z英文字母
    * <span class="hljs-doctag">@example</span>
    * let n=numToEng(1);//返回'a'
  */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">numToEng</span>(<span class="hljs-params">i: <span class="hljs-built_in">number</span>, big: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-built_in">string</span>;

-------------------------------numToEng0_26--------------------------------------
<span class="hljs-comment">/**
    * <span class="hljs-doctag">@description</span> 通过ASCII码的方式将1-26转换为字母a-z(可大写可小写)
    * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} num 要转换的阿拉伯数字1-26
    * <span class="hljs-doctag">@param</span> {<span class="hljs-type">boolean</span>} big true:大写，false|不传:为小写
    * <span class="hljs-doctag">@author</span> <span class="hljs-variable">zl</span>-fire 2021/09/01
    * <span class="hljs-doctag">@return</span> {<span class="hljs-type">string</span>} 英文字母a-zA-Z
    * <span class="hljs-doctag">@example</span>
    * let n=numToEng0_26(1);//返回'a'
  */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">numToEng0_26</span>(<span class="hljs-params">num: <span class="hljs-built_in">number</span>, big: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-built_in">string</span>;

-------------------------------resolveHtmlPageMenu--------------------------------------

<span class="hljs-comment">/**
    * <span class="hljs-doctag">@description</span> 传入能获取所有页面元素的$对象，从中获取由h1---h6组合成的树结构
    * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} $ 能获取所有页面元素的$对象，这里使用的cheerio
    * <span class="hljs-doctag">@author</span> <span class="hljs-variable">zl</span>-fire 2021/09/01
    * <span class="hljs-doctag">@return</span> {<span class="hljs-type">object[]</span>} json树结构
  */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveHtmlPageMenu</span>(<span class="hljs-params">$: <span class="hljs-built_in">object</span></span>): <span class="hljs-built_in">object</span>[];
</code></pre>
</article></section></body></html>
<script>
var callback=function (par) {
                    location.hash = $(par).attr("data-id");
                };
//设置垂直菜单的鼠标事件
var i = 0;
$("." + 'zl-ver-menu' + " li").each(function () {
    var _this = this;

    if (!$(this).children("ul")[0]) {
        if (true && false) {
            // 当没有给定任何锚点时，打开就选中第一个
            if (i == 0 && location.hash == "") {
                i++;
                setTimeout(function () {
                    $(_this).click();
                    $(_this).addClass("summary-active ");
                }, 0);
            }
        }
        $(this).on({
            mouseover: function mouseover() {
                $(this).css({ "background-color": "#E9F2FF" });
            },
            mouseout: function mouseout() {
                $(this).css({ "background-color": "transparent" });
            }
        });
    }
});
// 给菜单添加点击事件，实现选中效果
$("." + 'zl-ver-menu'  + " li").each(function () {
    if (!$(this).children("ul")[0]) {
        $(this).click(function () {
            $("." + 'zl-ver-menu'  + " li").removeClass("summary-active ");
            $(this).addClass("summary-active ");
            callback(this);
        });
    }
});
// 当点击了菜单标题时，展开和搜索图标
$("." + 'zl-ver-menu'  + " .tit-menu").click(function () {
    $(this).parent().children("ul").slideToggle();
    var classv = $(this).find("i").attr("class");
    //这里因为字符串triangle_open包含了字符串triangle，所有顺序要注意下
    if (classv.includes("triangle_open")) {
        $(this).find("i").removeClass("triangle_open").addClass("triangle"); //关闭
    } else {
        $(this).find("i").removeClass("triangle").addClass("triangle_open"); //打开
    }
});
if (!true) {
    $("." + 'zl-ver-menu'  + "> ul >li ul").hide();
    $(".tit-menu i").removeClass("triangle").addClass("triangle_open");
}
</script>

            </body>
        </html>